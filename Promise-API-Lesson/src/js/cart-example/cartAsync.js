"use strict";

import uniqid from "uniqid";

// Иморт массива items из отдельного файла=============================================

import { items } from "./cart-items";

// Объявление объекта cart=============================================================

export const cart = {
  items,
  add(itemName) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        const item = {
          id: uniqid("goods-", "-new"),
          name: itemName,
        };

        this.items.push(item);

        resolve(item);
      }, 300);
    });
  },
  remove(id) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        this.items = this.items.filter((item) => item.id !== id);

        resolve(id);
      }, 300);
    });
  },
  // Пример синхронной функции, которая возвращает мгновенный промис без таймаута
  // Promise.resolve позволяет взять синхронную функцию, по результату которой необходимо вызвать какое-то действие, но она ничего не
  // возвращает и превратить ее в функцию, которая возвращает промис и позволяет внешнему коду использовать ее результат
  // Она выполняется после всего синхронного кода, асинхронно, но мгновенно==============================
  // !!!!!!!!!!! Статический метод Reject в промисах практически никогда не используется, поскольку промис реджектится когда произошла какая-то ошибка
  // !!!!!!!!!!! и в этом случае мы можем использовать статический метод Catch, который отлавливает ошибку и выполняет какой-то код.
  update(id) {
    return Promise.resolve(id);
  },
};
