"use strict";

// Паттерн State представляет собой объект (или класс), который содержит в себе список объектов, которые заинтересованы в получении оповещения об изменении
// состояния другого объекта. Идея в том, чтобы формировать зависмость один ко многим, при которой изменение состояния одного объекта приводит к автоматическому
// оповещению всех заинтересованных объектов.

// Создаем классы, которые будут являться наблюдателями

class Light {
  constructor(light) {
    this.light = light;
  }
}

class RedLight extends Light {
  constructor() {
    super("red");
  }

  sign() {
    return "STOP";
  }
}

class YellowLight extends Light {
  constructor() {
    super("yellow");
  }

  sign() {
    return "READY";
  }
}

class GreenLight extends Light {
  constructor() {
    super("green");
  }

  sign() {
    return "GO";
  }
}

// Создаем класс TrafficLight, который будет являться наблюдаемым объектом

class TrafficLight {
  constructor() {
    // Создаем список наблюдателей
    this.states = [new RedLight(), new YellowLight(), new GreenLight()];
    // Устанавливаем начальное состояние
    this.current = this.states[0];
  }

  // Создаем метод change(), который будет изменять состояние наблюдаемого объекта и оповещать всех наблюдателей об этом изменении состояния наблюдаемого объекта

  change() {
    // Получаем общее количество состояний
    const total = this.states.length;
    // Получаем индекс текущего состояния
    let index = this.states.findIndex((light) => light === this.current);
    // Проверка на то, что индекс текущего состояния не выходит за пределы общего количества состояний
    if (index + 1 < total) {
      // Устанавливаем текущее состояние в следующее состояние из списка состояний наблюдаемого объекта если индекс текущего состояния не
      // выходит за пределы общего количества состояний
      this.current = this.states[index + 1];
    } else {
      // Устанавливаем текущее состояние в первое состояние из списка состояний наблюдаемого объекта если индекс текущего состояния выходит за
      // пределы общего количества состояний
      this.current = this.states[0];
    }
  }

  // Создаем метод sign(), который будет возвращать текущее состояние наблюдаемого объекта

  sign() {
    return this.current.sign();
  }
}

// Создаем экземпляр класса TrafficLight

const traffic = new TrafficLight();

// Выводим в консоль текущее состояние наблюдаемого объекта

console.log(traffic.sign());

// Изменяем состояние наблюдаемого объекта

traffic.change();

// Выводим в консоль текущее состояние наблюдаемого объекта

console.log(traffic.sign());

// Изменяем состояние наблюдаемого объекта

traffic.change();

// Выводим в консоль текущее состояние наблюдаемого объекта

console.log(traffic.sign());
